// --------------------------------------------------------------------------------------------
// The following code is automatically generated by the gen-mongo-dao tool.
// Please do not modify this code manually to avoid being overwritten in the next generation.
// For more tool details, please click the link to view https://github.com/dobyte/gen-mongo-dao
// --------------------------------------------------------------------------------------------

package internal

import (
	"context"
	"errors"
	"example/dao/counter"
	"example/model/user"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"time"
)

type FilterFunc func(cols *Columns) interface{}
type UpdateFunc func(cols *Columns) interface{}
type FindOneOptionsFunc func(cols *Columns) *options.FindOneOptions
type FindManyOptionsFunc func(cols *Columns) *options.FindOptions
type UpdateOptionsFunc func(cols *Columns) *options.UpdateOptions
type DeleteOptionsFunc func(cols *Columns) *options.DeleteOptions
type InsertOneOptionsFunc func(cols *Columns) *options.InsertOneOptions
type InsertManyOptionsFunc func(cols *Columns) *options.InsertManyOptions

type User struct {
	Columns    *Columns
	Database   *mongo.Database
	Collection *mongo.Collection
}

type Columns struct {
	ID             string
	UID            string
	Account        string
	Password       string
	Salt           string
	Mobile         string
	Email          string
	Nickname       string
	Signature      string
	Gender         string
	Level          string
	Experience     string
	Coin           string
	Type           string
	Status         string
	DeviceID       string
	ThirdPlatforms string
	RegisterIP     string
	RegisterTime   string
	LastLoginIP    string
	LastLoginTime  string
}

var userColumns = &Columns{
	ID:             "_id",
	UID:            "uid",
	Account:        "account",
	Password:       "password",
	Salt:           "salt",
	Mobile:         "mobile",
	Email:          "email",
	Nickname:       "nickname",
	Signature:      "signature",
	Gender:         "gender",
	Level:          "level",
	Experience:     "experience",
	Coin:           "coin",
	Type:           "type",
	Status:         "status",
	DeviceID:       "device_id",
	ThirdPlatforms: "third_platforms",
	RegisterIP:     "register_ip",
	RegisterTime:   "register_time",
	LastLoginIP:    "last_login_ip",
	LastLoginTime:  "last_login_time",
}

func NewUser(db *mongo.Database) *User {
	return &User{
		Columns:    userColumns,
		Database:   db,
		Collection: db.Collection("user"),
	}
}

// InsertOne executes an insert command to insert a single document into the collection.
func (dao *User) InsertOne(ctx context.Context, model *user.User, optionsFunc ...InsertOneOptionsFunc) (*mongo.InsertOneResult, error) {
	if model == nil {
		return nil, errors.New("model is nil")
	}

	if err := dao.autofill(ctx, model); err != nil {
		return nil, err
	}

	var opts *options.InsertOneOptions

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	return dao.Collection.InsertOne(ctx, model, opts)
}

// InsertMany executes an insert command to insert multiple documents into the collection.
func (dao *User) InsertMany(ctx context.Context, models []*user.User, optionsFunc ...InsertManyOptionsFunc) (*mongo.InsertManyResult, error) {
	if len(models) == 0 {
		return nil, errors.New("models is empty")
	}

	documents := make([]interface{}, 0, len(models))
	for i := range models {
		model := models[i]
		if err := dao.autofill(ctx, model); err != nil {
			return nil, err
		}
		documents = append(documents, model)
	}

	var opts *options.InsertManyOptions

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	return dao.Collection.InsertMany(ctx, documents, opts)
}

// UpdateOne executes an update command to update at most one document in the collection.
func (dao *User) UpdateOne(ctx context.Context, filterFunc FilterFunc, updateFunc UpdateFunc, optionsFunc ...UpdateOptionsFunc) (*mongo.UpdateResult, error) {
	var (
		opts   *options.UpdateOptions
		filter = filterFunc(dao.Columns)
		update = updateFunc(dao.Columns)
	)

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	return dao.Collection.UpdateOne(ctx, filter, update, opts)
}

// UpdateOneByID executes an update command to update at most one document in the collection.
func (dao *User) UpdateOneByID(ctx context.Context, id string, updateFunc UpdateFunc, optionsFunc ...UpdateOptionsFunc) (*mongo.UpdateResult, error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	return dao.UpdateOne(ctx, func(cols *Columns) interface{} {
		return bson.M{"_id": objectID}
	}, updateFunc, optionsFunc...)
}

// UpdateMany executes an update command to update documents in the collection.
func (dao *User) UpdateMany(ctx context.Context, filterFunc FilterFunc, updateFunc UpdateFunc, optionsFunc ...UpdateOptionsFunc) (*mongo.UpdateResult, error) {
	var (
		opts   *options.UpdateOptions
		filter = filterFunc(dao.Columns)
		update = updateFunc(dao.Columns)
	)

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	return dao.Collection.UpdateMany(ctx, filter, update, opts)
}

// FindOne executes a find command and returns a model for one document in the collection.
func (dao *User) FindOne(ctx context.Context, filterFunc FilterFunc, optionsFunc ...FindOneOptionsFunc) (*user.User, error) {
	var (
		opts   *options.FindOneOptions
		model  = &user.User{}
		filter = filterFunc(dao.Columns)
	)

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	err := dao.Collection.FindOne(ctx, filter, opts).Decode(model)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	}

	return model, nil
}

// FindOneByID executes a find command and returns a model for one document in the collection.
func (dao *User) FindOneByID(ctx context.Context, id string, optionsFunc ...FindOneOptionsFunc) (*user.User, error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	return dao.FindOne(ctx, func(cols *Columns) interface{} {
		return bson.M{"_id": objectID}
	}, optionsFunc...)
}

// FindMany executes a find command and returns many models the matching documents in the collection.
func (dao *User) FindMany(ctx context.Context, filterFunc FilterFunc, optionsFunc ...FindManyOptionsFunc) ([]*user.User, error) {
	var (
		opts   *options.FindOptions
		filter = filterFunc(dao.Columns)
	)

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	cur, err := dao.Collection.Find(ctx, filter, opts)
	if err != nil {
		return nil, err
	}

	models := make([]*user.User, 0)

	if err = cur.All(ctx, &models); err != nil {
		return nil, err
	}

	return models, nil
}

// DeleteOne executes a delete command to delete at most one document from the collection.
func (dao *User) DeleteOne(ctx context.Context, filterFunc FilterFunc, optionsFunc ...DeleteOptionsFunc) (*mongo.DeleteResult, error) {
	var (
		opts   *options.DeleteOptions
		filter = filterFunc(dao.Columns)
	)

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	return dao.Collection.DeleteOne(ctx, filter, opts)
}

// DeleteOneByID executes a delete command to delete at most one document from the collection.
func (dao *User) DeleteOneByID(ctx context.Context, id string, optionsFunc ...DeleteOptionsFunc) (*mongo.DeleteResult, error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	return dao.DeleteOne(ctx, func(cols *Columns) interface{} {
		return bson.M{"_id": objectID}
	}, optionsFunc...)
}

// DeleteMany executes a delete command to delete documents from the collection.
func (dao *User) DeleteMany(ctx context.Context, filterFunc FilterFunc, optionsFunc ...DeleteOptionsFunc) (*mongo.DeleteResult, error) {
	var (
		opts   *options.DeleteOptions
		filter = filterFunc(dao.Columns)
	)

	if len(optionsFunc) > 0 {
		opts = optionsFunc[0](dao.Columns)
	}

	return dao.Collection.DeleteMany(ctx, filter, opts)
}

// autofill when inserting data
func (dao *User) autofill(ctx context.Context, model *user.User) error {
	if model.ID.IsZero() {
		model.ID = primitive.NewObjectID()
	}

	if model.UID == 0 {
		if id, err := counter.NewCounter(dao.Database).Incr(ctx, "uid"); err != nil {
			return err
		} else {
			model.UID = int32(id)
		}
	}

	if model.RegisterTime == 0 {
		model.RegisterTime = primitive.NewDateTimeFromTime(time.Now())
	}

	if model.LastLoginTime == 0 {
		model.LastLoginTime = primitive.NewDateTimeFromTime(time.Now())
	}

	return nil
}
