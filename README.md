# mongo-dao-generator

##### [中文文档](README-zh.md)

### 1.Introduction

mongo-dao-generator is a tool for automatically generating MongoDB Data Access Object.

### 2.Advantage

* Supports automatic filling of primitive.ObjectID and primitive.DateTime types.

* Supports automatic increment of int, int8, int16, int32, int64, uint, uint8, uint16, uint32 and uint64 types.

* Provides a unified generation scheme for database fields, avoiding the problem of database fields that can be seen everywhere in business codes.

* Provides various database operation interfaces including InsertOne, InsertMany, UpdateOne, UpdateOneByID, UpdateMany, FindOne, FindOneByID, FindMany, DeleteOne, DeleteOneByID, DeleteMany, Count, Aggregate, etc.

* Provides the ability to expand the database operation interface.

* Provides two package solutions: subcontracting and non-subcontracting.

* Supports customization of directory and file name styles.

### 3.Download and install

```bash
go env -w GOSUMDB=off
go intall github.com/dobyte/mongo-dao-generator@latest
go env -w GOSUMDB=on
```

### 4.Usage

```bash
Usage of mongo-dao-generator:
    mongo-dao-generator [flags] -model-dir=. -model-names=T,T -dao-dir=./dao
For more information, see:
    https://github.com/dobyte/mongo-dao-generator
Flags:
  -counter-name string
        specify the counter name; default is counter
  -dao-dir string
        specify the output directory of dao files; must be set
  -dao-pkg-path string
        specify the package path corresponding to the output directory of the dao files; automatically generated by default
  -file-style string
        specify the generation style for file; options: kebab | underscore | lower | camel | pascal; default is underscore (default "underscore")
  -model-dir string
        specify the model directory; must be set
  -model-names string
        specify the comma-separated list of model name; must be set
  -model-pkg-alias string
        specify a model package alias; default no alias
  -model-pkg-path string
        specify the package path corresponding to the model directory; automatically calculated by default
  -subpkg-enable
        specify whether to enable subpkg; default disable
  -subpkg-style string
        specify the generation style for subpkg; options: kebab | underscore | lower | camel | pascal; default is kebab (default "kebab")
```

### 5.Extension tags

The parsing of gen tags is supported in the model definition, and the following tag parsing is currently supported:

| Tag Name |                                                            | Example            | Description                                                                                         |
| -------- | ---------------------------------------------------------- | ------------------ | --------------------------------------------------------------------------------------------------- |
| autoFill | primitive.ObjectID、primitive.DateTime                      | gen:"autoFill"     |                                                                                                     |
| autoIncr | int、int8、int16、int32、int64、uint、uint8、uint16、uint32、uint64 | gen:"autoIncr:uid" | The increment is atomic and the counter code is generated synchronously when the code is generated. |

### 6.Example

###### 6-1.Create model

model/mail.go

```go
package model

import "go.mongodb.org/mongo-driver/bson/primitive"

//go:generate mongo-dao-generator -model-dir=. -model-names=Mail -dao-dir=../dao/
type Mail struct {
    ID       primitive.ObjectID `bson:"_id" gen:"autoFill"`       // mail id
    Title    string             `bson:"title"`                    // mail title
    Content  string             `bson:"content"`                  // mail content
    Sender   int64              `bson:"sender"`                   // sender's uid
    Receiver int64              `bson:"receiver"`                 // receiver's uid
    Status   int                `bson:"status"`                   // mail status
    SendTime primitive.DateTime `bson:"send_time" gen:"autoFill"` // send time
}
```

###### 6-2.Generate dao files

```bash
go generate ./...
```

###### 6-3.Generated dao file example

dao/internal/mail.go

```go
// --------------------------------------------------------------------------------------------
// The following code is automatically generated by the mongo-dao-generator tool.
// Please do not modify this code manually to avoid being overwritten in the next generation.
// For more tool details, please click the link to view https://github.com/dobyte/mongo-dao-generator
// --------------------------------------------------------------------------------------------

package internal

import (
    "context"
    "errors"
    models "github.com/dobyte/mongo-dao-generator/example/model"
    "go.mongodb.org/mongo-driver/bson"
    "go.mongodb.org/mongo-driver/bson/primitive"
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
    "time"
)

type MailFilterFunc func(cols *MailColumns) interface{}
type MailUpdateFunc func(cols *MailColumns) interface{}
type MailPipelineFunc func(cols *MailColumns) interface{}
type MailCountOptionsFunc func(cols *MailColumns) *options.CountOptions
type MailAggregateOptionsFunc func(cols *MailColumns) *options.AggregateOptions
type MailFindOneOptionsFunc func(cols *MailColumns) *options.FindOneOptions
type MailFindManyOptionsFunc func(cols *MailColumns) *options.FindOptions
type MailUpdateOptionsFunc func(cols *MailColumns) *options.UpdateOptions
type MailDeleteOptionsFunc func(cols *MailColumns) *options.DeleteOptions
type MailInsertOneOptionsFunc func(cols *MailColumns) *options.InsertOneOptions
type MailInsertManyOptionsFunc func(cols *MailColumns) *options.InsertManyOptions

type Mail struct {
    Columns    *MailColumns
    Database   *mongo.Database
    Collection *mongo.Collection
}

type MailColumns struct {
    ID       string
    Title    string
    Content  string
    Sender   string
    Receiver string
    Status   string
    SendTime string
}

var mailColumns = &MailColumns{
    ID:       "_id",
    Title:    "title",
    Content:  "content",
    Sender:   "sender",
    Receiver: "receiver",
    Status:   "status",
    SendTime: "send_time",
}

func NewMail(db *mongo.Database) *Mail {
    return &Mail{
        Columns:    mailColumns,
        Database:   db,
        Collection: db.Collection("mail"),
    }
}

// Count returns the number of documents in the collection.
func (dao *Mail) Count(ctx context.Context, filterFunc MailFilterFunc, optionsFunc ...MailCountOptionsFunc) (int64, error) {
    var (
        opts   *options.CountOptions
        filter = filterFunc(dao.Columns)
    )

    if len(optionsFunc) > 0 {
        opts = optionsFunc[0](dao.Columns)
    }

    return dao.Collection.CountDocuments(ctx, filter, opts)
}

// Aggregate executes an aggregate command against the collection and returns a cursor over the resulting documents.
func (dao *Mail) Aggregate(ctx context.Context, pipelineFunc MailPipelineFunc, optionsFunc ...MailAggregateOptionsFunc) (*mongo.Cursor, error) {
    var (
        opts     *options.AggregateOptions
        pipeline = pipelineFunc(dao.Columns)
    )

    if len(optionsFunc) > 0 {
        opts = optionsFunc[0](dao.Columns)
    }

    return dao.Collection.Aggregate(ctx, pipeline, opts)
}

// InsertOne executes an insert command to insert a single document into the collection.
func (dao *Mail) InsertOne(ctx context.Context, model *models.Mail, optionsFunc ...MailInsertOneOptionsFunc) (*mongo.InsertOneResult, error) {
    if model == nil {
        return nil, errors.New("model is nil")
    }

    if err := dao.autofill(ctx, model); err != nil {
        return nil, err
    }

    var opts *options.InsertOneOptions

    if len(optionsFunc) > 0 {
        opts = optionsFunc[0](dao.Columns)
    }

    return dao.Collection.InsertOne(ctx, model, opts)
}

// InsertMany executes an insert command to insert multiple documents into the collection.
func (dao *Mail) InsertMany(ctx context.Context, models []*models.Mail, optionsFunc ...MailInsertManyOptionsFunc) (*mongo.InsertManyResult, error) {
    if len(models) == 0 {
        return nil, errors.New("models is empty")
    }

    documents := make([]interface{}, 0, len(models))
    for i := range models {
        model := models[i]
        if err := dao.autofill(ctx, model); err != nil {
            return nil, err
        }
        documents = append(documents, model)
    }

    var opts *options.InsertManyOptions

    if len(optionsFunc) > 0 {
        opts = optionsFunc[0](dao.Columns)
    }

    return dao.Collection.InsertMany(ctx, documents, opts)
}

// UpdateOne executes an update command to update at most one document in the collection.
func (dao *Mail) UpdateOne(ctx context.Context, filterFunc MailFilterFunc, updateFunc MailUpdateFunc, optionsFunc ...MailUpdateOptionsFunc) (*mongo.UpdateResult, error) {
    var (
        opts   *options.UpdateOptions
        filter = filterFunc(dao.Columns)
        update = updateFunc(dao.Columns)
    )

    if len(optionsFunc) > 0 {
        opts = optionsFunc[0](dao.Columns)
    }

    return dao.Collection.UpdateOne(ctx, filter, update, opts)
}

// UpdateOneByID executes an update command to update at most one document in the collection.
func (dao *Mail) UpdateOneByID(ctx context.Context, id string, updateFunc MailUpdateFunc, optionsFunc ...MailUpdateOptionsFunc) (*mongo.UpdateResult, error) {
    objectID, err := primitive.ObjectIDFromHex(id)
    if err != nil {
        return nil, err
    }

    return dao.UpdateOne(ctx, func(cols *MailColumns) interface{} {
        return bson.M{"_id": objectID}
    }, updateFunc, optionsFunc...)
}

// UpdateMany executes an update command to update documents in the collection.
func (dao *Mail) UpdateMany(ctx context.Context, filterFunc MailFilterFunc, updateFunc MailUpdateFunc, optionsFunc ...MailUpdateOptionsFunc) (*mongo.UpdateResult, error) {
    var (
        opts   *options.UpdateOptions
        filter = filterFunc(dao.Columns)
        update = updateFunc(dao.Columns)
    )

    if len(optionsFunc) > 0 {
        opts = optionsFunc[0](dao.Columns)
    }

    return dao.Collection.UpdateMany(ctx, filter, update, opts)
}

// FindOne executes a find command and returns a model for one document in the collection.
func (dao *Mail) FindOne(ctx context.Context, filterFunc MailFilterFunc, optionsFunc ...MailFindOneOptionsFunc) (*models.Mail, error) {
    var (
        opts   *options.FindOneOptions
        model  = &models.Mail{}
        filter = filterFunc(dao.Columns)
    )

    if len(optionsFunc) > 0 {
        opts = optionsFunc[0](dao.Columns)
    }

    err := dao.Collection.FindOne(ctx, filter, opts).Decode(model)
    if err != nil {
        if err == mongo.ErrNoDocuments {
            return nil, nil
        }
        return nil, err
    }

    return model, nil
}

// FindOneByID executes a find command and returns a model for one document in the collection.
func (dao *Mail) FindOneByID(ctx context.Context, id string, optionsFunc ...MailFindOneOptionsFunc) (*models.Mail, error) {
    objectID, err := primitive.ObjectIDFromHex(id)
    if err != nil {
        return nil, err
    }

    return dao.FindOne(ctx, func(cols *MailColumns) interface{} {
        return bson.M{"_id": objectID}
    }, optionsFunc...)
}

// FindMany executes a find command and returns many models the matching documents in the collection.
func (dao *Mail) FindMany(ctx context.Context, filterFunc MailFilterFunc, optionsFunc ...MailFindManyOptionsFunc) ([]*models.Mail, error) {
    var (
        opts   *options.FindOptions
        filter = filterFunc(dao.Columns)
    )

    if len(optionsFunc) > 0 {
        opts = optionsFunc[0](dao.Columns)
    }

    cur, err := dao.Collection.Find(ctx, filter, opts)
    if err != nil {
        return nil, err
    }

    models := make([]*models.Mail, 0)

    if err = cur.All(ctx, &models); err != nil {
        return nil, err
    }

    return models, nil
}

// DeleteOne executes a delete command to delete at most one document from the collection.
func (dao *Mail) DeleteOne(ctx context.Context, filterFunc MailFilterFunc, optionsFunc ...MailDeleteOptionsFunc) (*mongo.DeleteResult, error) {
    var (
    opts   *options.DeleteOptions
    filter = filterFunc(dao.Columns)
    )

    if len(optionsFunc) > 0 {
        opts = optionsFunc[0](dao.Columns)
    }

    return dao.Collection.DeleteOne(ctx, filter, opts)
}

// DeleteOneByID executes a delete command to delete at most one document from the collection.
func (dao *Mail) DeleteOneByID(ctx context.Context, id string, optionsFunc ...MailDeleteOptionsFunc) (*mongo.DeleteResult, error) {
    objectID, err := primitive.ObjectIDFromHex(id)
    if err != nil {
        return nil, err
    }

    return dao.DeleteOne(ctx, func(cols *MailColumns) interface{} {
        return bson.M{"_id": objectID}
    }, optionsFunc...)
}

// DeleteMany executes a delete command to delete documents from the collection.
func (dao *Mail) DeleteMany(ctx context.Context, filterFunc MailFilterFunc, optionsFunc ...MailDeleteOptionsFunc) (*mongo.DeleteResult, error) {
    var (
    opts   *options.DeleteOptions
    filter = filterFunc(dao.Columns)
    )

    if len(optionsFunc) > 0 {
        opts = optionsFunc[0](dao.Columns)
    }

    return dao.Collection.DeleteMany(ctx, filter, opts)
}

// autofill when inserting data
func (dao *Mail) autofill(ctx context.Context, model *models.Mail) error {
    if model.ID.IsZero() {
        model.ID = primitive.NewObjectID()
    }

    if model.SendTime == 0 {
        model.SendTime = primitive.NewDateTimeFromTime(time.Now())
    }

    return nil
}
```

dao/mail.go

```go
package dao

import (
    "github.com/dobyte/mongo-dao-generator/example/dao/internal"
    "go.mongodb.org/mongo-driver/mongo"
)

type MailColumns = internal.MailColumns

type Mail struct {
    *internal.Mail
}

func NewMail(db *mongo.Database) *Mail {
    return &Mail{Mail: internal.NewMail(db)}
}
```

###### 6-4.Use the generated dao file

```go
package main

import (
    "context"
    "github.com/dobyte/mongo-dao-generator/example/dao"
    "github.com/dobyte/mongo-dao-generator/example/model"
    "go.mongodb.org/mongo-driver/bson"
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
    "go.mongodb.org/mongo-driver/mongo/readpref"
    "log"
    "time"
)

func main() {
    var (
    uri     = "mongodb://root:12345678@127.0.0.1:27017"
    opts    = options.Client().ApplyURI(uri)
    baseCtx = context.Background()
    )

    ctx, cancel := context.WithTimeout(baseCtx, 5*time.Second)
    client, err := mongo.Connect(ctx, opts)
    cancel()
    if err != nil {
        log.Fatalf("connect mongo server failed: %v", err)
    }

    ctx, cancel = context.WithTimeout(baseCtx, 5*time.Second)
    defer cancel()
    err = client.Ping(ctx, readpref.Primary())
    cancel()
    if err != nil {
        log.Fatalf("ping mongo server failed: %v", err)
    }

    db := client.Database("dao_test")

    mailDao := dao.NewMail(db)

    _, err = mailDao.InsertOne(baseCtx, &model.Mail{
        Title:    "mongo-dao-generator introduction",
        Content:  "the mongo-dao-generator is a tool for automatically generating MongoDB Data Access Object.",
        Sender:   1,
        Receiver: 2,
        Status:   1,
    })
    if err != nil {
        log.Fatalf("failed to insert into mongo database: %v", err)
    }

    mail, err := mailDao.FindOne(baseCtx, func(cols *dao.MailColumns) interface{} {
        return bson.M{cols.Receiver: 2}
    })
    if err != nil {
        log.Fatalf("failed to find a row of data from mongo database: %v", err)
    }

    log.Printf("%+v", mail)
}
```

execute result

```bash
2023/02/17 16:05:31 &{ID:ObjectID("63ef354a4ddc485f0d9c5ea3") Title:mongo-dao-generator introduction Content:the mongo-dao-generator is a tool for automatically generating MongoDB Data Access Object. Sender:1 Receiver:2 Status:1 SendTime:1676621130323}
```